{"name":"Consistent.js","tagline":"Consistent is a small and simple Javascript framework to enable an abstract model to be synced with the DOM.","body":"Consistent.js\r\n=============\r\n\r\nConsistent is a small and simple Javascript framework to enable an abstract model to be synced with the DOM. Consistent is designed to be easy to use and understand for developers already using jQuery, and it doesn’t prevent you from using jQuery at the same time.\r\n\r\n[![Build Status](https://travis-ci.org/karlvr/consistent.js.png)](https://travis-ci.org/karlvr/consistent.js)\r\n\r\nIntroduction\r\n------------\r\nUse Consistent to create a _scope_, and then bind DOM nodes to it. Consistent inspects the DOM nodes (and their children) to learn how to relate them to the scope.\r\n\r\nThe scope starts with no properties. You add properties to the scope and then apply them to the DOM. In your HTML markup you add `ct...` attributes to declare to Consistent how to use the scope’s properties. You can also use `data-ct...` instead of `ct...` if you prefer.\r\n\r\nThe scope contains a `$` property in which Consistent keeps its functions and scope. For example, when you want to apply the scope you call `scope.$.apply()`. This `$` property separates the properties you add to the scope from Consistent, so you can add properties with any other name. Note that this `$` is nothing to do with jQuery and doesn’t interfere with it as it is contained in the scope.\r\n\r\nThe scope contains scalar values, such as booleans, strings and numbers, and value functions, that return a calculated value. The scope also contains any event handler functions you create. To separate these event handlers from your values they are stored in properties beginning with a `$`, e.g. `$handleClick`.\r\n\r\nConsistent includes a jQuery plugin, and the examples below show this approach. Consistent does not however require jQuery and can be used without it.\r\n\r\n```html\r\n<script src=\"src/consistent.js\"></script>\r\n<script src=\"src/jquery.consistent.js\"></script>\r\n```\r\n\r\nOr use a minified and combined version. The minified and combined script for Consistent and the jQuery plugin is just over 7KB.\r\n\r\n```html\r\n<script src=\"lib/consistent-for-jquery.min.js\"></script>\r\n```\r\n\r\n### Substitution\r\nSet the contents of an `h1` element with the `title` property in the scope.\r\n\r\n```html\r\n<h1 ct=\"title\"></h1>\r\n```\r\n\r\nNow create a scope using the jQuery plugin, and assign a value to it.\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent();\r\nscope.title = \"Consistent.js\";\r\nscope.$.apply();\r\n```\r\n\r\nThe `h1` element will now have its body changed to \"Consistent.js\".\r\n\r\nNotice that after changing properties in the scope you need to call _apply_ to instruct Consistent to update the DOM. You can also apply changes to the scope like this, which is equivalent:\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent();\r\nscope.$.apply(function() {\r\n\tthis.title = \"Consistent.js\";\r\n});\r\n```\r\n\r\nOr even the following, as most things in Consistent are chainable:\r\n\r\n```javascript\r\n$(\"h1\").consistent().$.apply(function() {\r\n\tthis.title = \"Consistent.js\";\r\n});\r\n```\r\n\r\nNote that if a scope property is undefined, Consistent does not change the DOM.\r\n\r\nHow Consistent applies the scope value to the DOM depends upon the element. For most elements the `innerHTML` is set to the scope value. There are the following exceptions:\r\n* `<input>`, `select` and `textarea` elements have their value set, or are checked, as appropriate. See Forms below.\r\n* `<img>` has its `src` attribute set\r\n\r\n### Templating\r\n\r\nConsistent supports pluggable templating engines. The examples use [Hogan](http://twitter.github.io/hogan.js/). Any templating engine that provides `compile(string)` and `render(object)` methods will work.\r\n\r\n```html\r\n<h1 ct-tmpl=\"Welcome to {{name}}\"></h1>\r\n```\r\n\r\nNow configure Consistent to use Hogan as its templating engine, and populate the scope.\r\n\r\n```javascript\r\nConsistent.defaultOptions.templateEngine = Hogan;\r\nvar scope = $(\"h1\").consistent();\r\nscope.name = \"Consistent.js\";\r\nscope.$.apply();\r\n```\r\n\r\nYou can also reference templates by an id, rather than writing them inline:\r\n\r\n```html\r\n<h1 ct-tmpl-id=\"h1-template\"></h1>\r\n\r\n<script id=\"h1-template\" type=\"text/x-hogan-template\">\r\n\tWelcome to {{name}}\r\n</script>\r\n```\r\n\r\nNote that Consistent will re-render the templates and thus recreate the DOM nodes each time the scope is applied.\r\n\r\nIf you need to create a large DOM structure and then have it bound to a scope, consider creating it first using templating and then binding it with Consistent.\r\n\r\n### Visibility\r\n\r\nConsistent can show and hide nodes based on the scope.\r\n\r\n```html\r\n<h1 ct-show=\"showTitle\">My title</h1>\r\n```\r\n\r\nYou can also use `ct-hide` to hide the element when the scope property is true.\r\n\r\nNow create a scope and set the showTitle property. Consistent will show or hide the element using a `display:none` style. Consistent also restores the old value of `display` when re-showing, in case it was set to something specifically.\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent();\r\nscope.showTitle = true;\r\nscope.$.apply();\r\n```\r\n\r\nYou can override the behaviour of showing and hiding elements. For example, you may want to fade elements in and out. See the Options section for more information.\r\n\r\n### Value functions\r\n\r\nAs well as adding scalar values to the scope, you can also add value functions. In this case the function is executed each time the scope is applied and its return value is used. Value functions allow a scope property to be calculated dynamically.\r\n\r\n```html\r\n<div id=\"container\">\r\n\t<p>The number of people is <span ct=\"numberOfPeople\">&nbsp;</span>.</p>\r\n</div>\r\n```\r\n\r\nThe `&nbsp;` above is sometimes necessary for IE 6 (is anyone still?) which will otherwise collapse the whitespace around the `<span>` and you may get strange spacing.\r\n\r\n```javascript\r\nvar scope = $(\"#container\").consistent();\r\nvar people = [ \"Albert\", \"Bob\", \"Carl\", \"Donald\" ];\r\nscope.numberOfPeople = function() {\r\n\treturn people.length;\r\n};\r\nscope.$.apply();\r\n```\r\n\r\nThe value function gets called with `this` set to the scope, and no arguments. As for other scope properties, if the value function returns `undefined` then no changes will be made to the DOM.\r\n\r\nWhen the scope is populated from the DOM using the `scope.$.update` function, or when a scope property is set manually using the `scope.$.set` function, and the scope contains a value function for the affected property; the value function is called with one argument - the incoming value. Your value function can ignore this if it doesn’t support updates.\r\n\r\n```javascript\r\nvar numberOfPeople = 5;\r\nscope.numberOfPeople = function(newValue) {\r\n\tif (typeof newValue !== \"undefined\") {\r\n\t\tnumberOfPeople = parseInt(newValue);\r\n\t} else {\r\n\t\treturn numberOfPeople;\r\n\t}\r\n}\r\n```\r\n\r\n### Form elements\r\n\r\nForm elements are automatically associated with the scope property with the same name as the element, and Consistent updates the form field’s value from the scope.\r\n\r\n```html\r\n<input type=\"text\" name=\"email\">\r\n<input type=\"checkbox\" name=\"optin\">\r\n```\r\n\r\nNote that we don’t explicitly specify the scope property, it defaults to the name. You can explicitly specify the scope property using the `ct` attribute.\r\n\r\nNow create a scope and set the elements’ values.\r\n\r\n```javascript\r\nvar scope = $(\"input\").consistent();\r\nscope.email = \"example@example.com\";\r\nscope.optin = true;\r\nscope.$.apply();\r\n```\r\n\r\nAll form elements are supported, including:\r\n* text fields\r\n* checkboxes\r\n* radio buttons\r\n* select (single and multiple selection)\r\n* textareas\r\n\r\nCheckboxes are usually represented by a boolean value in the scope. For groups of checkboxes with the same name they can be thought of as an array of values (the value attribute from the checkbox). If you have a boolean value in the scope, Consistent will not change it, but you may get some strange results if you have multiple checkboxes bound to the same property (with the same name with the default property binding). If the scope contains an array or no value for a checkbox’s bound property then Consistent will create an array. Consistent can also cope with scalar values for a checkbox, in which case they are matched to the checkbox’s value. Note that in this case Consistent may convert the property to an array if there are multiple checkboxes bound to the same property.\r\n\r\nFor `<select>` elements that can have multiple options selected, the scope property can be an array.\r\n\r\nConsistent automatically listens to the `change` event on form elements. When the `change` event fires, Consistent updates the scope with that element and then applies the scope. Note that the update is just for the element that fired the `change` event, it is not for all of the scope’s DOM nodes as it is if you call `scope.$.update()`. You can turn off this behaviour by setting `autoListenToChange` to false in the `options` object, either when the scope is created or when you bind the form elements.\r\n\r\n#### Disabled and Read only\r\n\r\nYou can control the `disabled` and `readOnly` properties of form elements.\r\n\r\n```html\r\n<input type=\"text\" name=\"email\" ct-disabled=\"locked\">\r\n```\r\n\r\n```javascript\r\nscope.locked = true;\r\n```\r\n\r\nIt is often useful to use a value function in this case, so that the disabled state of the form element is calculated dynamically each time the scope is applied.\r\n\r\nThe above shows how to control the `disabled` property, the full list is:\r\n* `ct-disabled`\r\n* `ct-enabled`\r\n* `ct-readonly`\r\n* `ct-readwrite`\r\n\r\nNote that for each of disabled and readonly there is the opposite so that you can best fit the option to the model.\r\n\r\n#### Select options\r\n\r\nYou can set the options array for a `<select>` element from the scope.\r\n\r\n```html\r\n<select name=\"product\" ct-options=\"products\"></select>\r\n```\r\n\r\nNow set the options array either as an array of scalar values, such as strings:\r\n\r\n```javascript\r\nscope.products = [ \"\", \"Lamp\", \"Bucket\", \"Axe\" ];\r\n```\r\n\r\nOr as an array of objects that separate the text and value:\r\n\r\n```javascript\r\nscope.products = [\r\n\t{},\r\n\t{ text: \"Lamp\", value: \"lamp\" },\r\n\t{ text: \"Bucket\", value: \"bucket\" },\r\n\t{ text: \"Axe\", value: \"axe\" }\r\n];\r\n```\r\n\r\nYou can also include `label` and `disabled` properties in the objects to set those properties in the created options.\r\n\r\nYou can of course bind the selected option as well, e.g. `scope.product = \"bucket\";`.\r\n\r\n### Events\r\n\r\nConsistent can add event listeners to DOM nodes which call functions in the scope. When you put an event handler function into the scope its name gets prefixed with a `$` in order to distinguish it from model values and functions. You must not include the `$` prefix when specifying the function in the DOM.\r\n\r\n```html\r\n<a href=\"#\" ct-on-click=\"handleClick\">Click me</a>\r\n```\r\n\r\nNow create a scope and provide the click handler. Note that in the DOM the handler is `handleClick` but to define it in the scope it is `$handleClick`. You must follow this pattern otherwise Consistent will not find your event handler function.\r\n\r\nIf you are using nested objects, the `$` prefix must be on the last part, e.g. `person.$handleClick`.\r\n\r\n```javascript\r\nvar scope = $(\"a\").consistent();\r\nscope.$handleClick = function(ev) {\r\n\tev.preventDefault();\r\n\talert(\"Click!\");\r\n};\r\n```\r\n\r\nThe handler function is called with `this` as the element that received the event, as in jQuery. There is also a second argument to the function which is the scope, in case you need it.\r\n\r\n```javascript\r\nscope.$handleClick = function(ev, scope) {\r\n\tscope.clickCount++;\r\n\tscope.$.apply();\r\n};\r\n```\r\n\r\nNote that we don’t need to call `apply` after defining the event handler in the scope, as we don’t need to change the DOM. The event listeners are added when the DOM nodes are bound to the scope, you just have to make sure the handler functions are defined by the time they are invoked.\r\n\r\n#### Shortcut\r\n\r\nThere is a shortcut for binding events, which is to omit the event name. This chooses the `click` event for most elements:\r\n\r\n```html\r\n<a href=\"#\" ct-on=\"handleClick\">Click me</a>\r\n```\r\n\r\nThe following special cases apply:\r\n  * `<input>`, `<textarea>` and `<select>` elements bind the `change` event\r\n  * `<form>` elements bind the `submit` event\r\n\r\n### Repeating blocks\r\n\r\nIf your scope contains array values, you can repeat blocks of DOM nodes to represent them.\r\n\r\n```html\r\n<ul>\r\n\t<li ct-repeat=\"people\" ct=\"name\"></li>\r\n</ul>\r\n```\r\n\r\n```javascript\r\nvar scope = $(\"ul\").consistent();\r\nscope.people = [\r\n\t{ name: \"Alfred\" },\r\n\t{ name: \"Bob\" },\r\n\t{ name: \"Carl\" }\r\n];\r\nscope.$.apply();\r\n```\r\n\r\nThis will result in a list containing three `<li>` elements, one for each of the people in the `scope.people` array. If you change the array, the DOM will be updated.\r\n\r\n```javascript\r\nscope.people.push({ name: \"Donald\" });\r\nscope.$.apply();\r\n```\r\n\r\nOr remove an item:\r\n\r\n```javascript\r\nscope.people.shift();\r\nscope.$.apply();\r\n```\r\n\r\nConsistent only creates new nodes when new items are added to the array. So any changes you make to the DOM outside of Consistent will be preserved, such as applying classes.\r\n\r\nConsistent creates a child scope for each repeated block, and the object in the array becomes its scope. Therefore each object in the array will have a `$` property added containing Consistent’s scope functionality. As the objects in the array are the child scopes, you can access the child scopes if you need to via the original array in the original scope.\r\n\r\nSee the Parent scopes section for essential information about parent and child scopes.\r\n\r\nRepeating clones the repeated element, including all of its children:\r\n\r\n```html\r\n<table>\r\n\t<tr ct-repeat=\"people\">\r\n\t\t<td>Person #<span ct=\"index\"></span></td>\r\n\t\t<td ct=\"name\"></td>\r\n\t\t<td ct=\"address\"></td>\r\n\t</tr>\r\n</table>\r\n```\r\n\r\n```javascript\r\nscope.index = function() {\r\n\treturn this.$.index;\r\n};\r\n```\r\n\r\nNote above that the scope contains a property `scope.$.index` that contains the 0-based index of the current repeated block. You can’t access this property directly from the DOM as it is inside the `$` object, but you can use a value function to access it (and to add 1 to it if you want the index to be 1-based!).\r\n\r\nAnother interesting thing is happening here, which will be clearer after reading the Parent scopes section. The `scope.index` value function is added to the parent scope. Each repeating block gets a child scope, which when it looks for the `index` property falls back to the parent scope. When a value function is called in a parent scope, `this` is set to the child scope. So `return this.$.index` returns the index of the child scope.\r\n\r\nIt is also possible to repeat a collection of elements. See Repeating multiple elements in the Advanced section.\r\n\r\n### Attributes\r\n\r\nYou can set DOM element attributes from the scope.\r\n\r\n```html\r\n<h1 ct-attr-title=\"headingTitle\">Consistent.js</h1>\r\n```\r\n\r\nNow create a scope and set the heading’s `title` attribute.\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent();\r\nscope.headingTitle = \"Welcome\";\r\nscope.$.apply();\r\n```\r\n\r\nIf you want to set DOM element properties, see the [Properties](#properties) section below.\r\n\r\n#### Class attributes\r\n\r\nClass attributes can be bound by declaring a `ct-attr-class` attribute, as above, however there is a shortcut for classes: `ct-class`.\r\n\r\n```html\r\n<h1 ct-class=\"headingClass\">Consistent.js</h1>\r\n```\r\n\r\n```javascript\r\nscope.headingClass = \"heading\";\r\nscope.headingClass = \"heading another-class\";\r\nscope.headingClass = [ \"heading\", \"another-class\" ];\r\n```\r\n\r\nNote that as well as being a shortcut, the `ct-class` supports array values, which are automatically converted to a space-separated string. If the scope contains an array value, `update` will convert the classes into an array when setting the scope.\r\n\r\nThe alternative `ct-add-class` attribute preserves existing classes. When the scope is applied the scope property determines the set of classes to add to the element in addition to its existing classes. The following example code is applied in order and shows how the class attribute changes.\r\n\r\n```html\r\n<h1 class=\"heading\" ct-add-class=\"headingClass\">Consistent.js</h1>\r\n```\r\n\r\n```javascript\r\nscope.headingClass = \"another-class\";\r\nscope.$.apply(); // class attribute is now \"heading another-class\"\r\n\r\nscope.headingClass = \"one two\";\r\nscope.$.apply(); // \"heading one two\"\r\n\r\nscope.headingClass = null;\r\nscope.$.apply(); // \"heading\"\r\n\r\nscope.headingClass = \"heading\";\r\nscope.$.apply(); // \"heading\"\r\n```\r\n\r\nIf you add classes to an element independent of Consistent, it will treat those classes as if they were existing and will not remove them when the scope is next applied, so everyone can play nicely together.\r\n\r\n#### Templating\r\n\r\nYou can also use templates to update attributes.\r\n\r\n```html\r\n<h1 ct-tmpl-attr-title=\"This is a story about {{subject}}\">Title</h1>\r\n\r\n<h1 ct-tmpl-id-attr-title=\"h1-title-template\">Title</h1>\r\n<script id=\"h1-title-template\" type=\"text/x-hogan-template\">This is a story about {{subject}}</script>\r\n```\r\n\r\n### Binding the scope to the DOM\r\n\r\nIn the examples above we’ve specifically bound the example nodes by their element name, this isn’t very realistic in practice. When you bind a DOM node to Consistent, all of its child nodes are bound as well, so you typically bind a container element:\r\n\r\n```html\r\n<div id=\"container\">\r\n\t<h3 ct=\"name\"></h3>\r\n\t<p ct=\"body\"></p>\r\n</div>\r\n```\r\n\r\nNow bind the scope.\r\n\r\n```javascript\r\n$(\"#container\").consistent();\r\n```\r\n\r\nOften you will have multiple blocks on the page and you’ll need to have an individual scope for each of them.\r\n\r\n```html\r\n<div class=\"container\">\r\n\t<p ct=\"body\"></p>\r\n</div>\r\n<div class=\"container\">\r\n\t<p ct=\"body\"></p>\r\n</div>\r\n```\r\n\r\nNow bind each to a new scope.\r\n\r\n```javascript\r\n$(\".container\").each(function() {\r\n\tvar scope = $(this).consistent();\r\n\tscope.body = \"Lorem ipsum\";\r\n\tscope.$.apply();\r\n});\r\n```\r\n\r\n### Getting the scope for a DOM node\r\n\r\nIf you need to get the existing scope for a node, you can follow the exact same pattern. Calling `.consistent()` again will return the existing scope.\r\n\r\n```javascript\r\n$(\".container\").each(function() {\r\n\tvar scope = $(this).consistent();\r\n\tscope.body = \"Change the body\";\r\n\tscope.$.apply();\r\n});\r\n```\r\n\r\nYou can also call the `Consistent.findScopeForNode(node)` function, if you just want to check if there’s a scope rather than create one.\r\n\r\n### Updating the scope from the DOM\r\n\r\nConsistent can inspect the DOM to populate the scope.\r\n\r\n```javascript\r\nvar scope = $(\"#container\").consistent();\r\nscope.$.update();\r\n```\r\n\r\nNote this doesn’t work for any properties that are using templates.\r\n\r\n### Watching for changes in the scope\r\n\r\nRegister a handler function to watch for changes to a particular property, or to the scope as a whole. Watch handler functions are called when `apply` is called on the scope, **before** the DOM has been updated.\r\n\r\n```javascript\r\nscope.$.watch(\"title\", function(key, newValue, oldValue) {\r\n\tthis.shortTitle = this.title.substring(0, 10);\r\n});\r\n\r\nscope.$.watch(function(changedKeys, snapshot, oldSnapshot) {\r\n\tthis.changeSummary = \"The following keys were changed: \" + changedKeys;\r\n});\r\n```\r\n\r\nThe snapshots passed to the watch handler function for the whole scope are created using the `scope.$.snapshot` function, and therefore do not have the `$` object, and value functions have been replaced with their value.\r\n\r\nNotice that you do not need to call `apply` if you change the scope inside a watch handler. A watch handler may be called multiple times in a single `apply` if the scope is changed by _other_ watch handlers.\r\n\r\nValue functions are watched based on their value. If the value returned by a value function changes between one apply and the next, the watch handler function will be called.\r\n\r\nIt is possible for watch handlers to cause an infinite loop, if the scope does not reach a steady state. This is especially likely if you use value functions that return a new value each time they are evaluated. Consistent detects excessive looping through the watch handler list and throws an exception to break it. The number of loops is set in `Consistent.settings.maxWatcherLoops`; the default should be good enough.\r\n\r\n### Populating the scope from another object\r\n\r\nOften you’ll receive data from an Ajax JSON response as a Javascript object. You can merge these into the scope using the `merge` function.\r\n\r\n```javascript\r\nvar scope = $(\"#item\").consistent();\r\n$.ajax({\r\n\tsuccess: function(data) {\r\n\t\tscope.$.merge(data);\r\n\t}\r\n})\r\n```\r\n\r\nNote that the merge is a shallow merge. For each key in the given object it adds it to the scope, replacing and values that are already there. If your scope has nested objects, they are replaced rather than merged.\r\n\r\n### Exporting the scope to a Javascript object\r\n\r\nThe scope contains some extra properties required for Consistent. Particularly the `$` property, where all of Consistent’s functionality lives (e.g. `scope.$.apply()`). It also contains event handler functions (property names prefixed with a `$`), and value functions.\r\n\r\n#### Snapshot\r\n\r\nUse the `snapshot` function to obtain a Javascript object without the `$` property, with properties prefixed with the `$` character (or whatever the `eventHandlerPrefix` option is set to) renamed to exclude the prefix, and with value functions evaluated and replaced with their value. This provides a snapshot of the state of the scope, and can be used to inspect values without being concerned with value functions, and without being concerned with the `$` prefix.\r\n\r\n```javascript\r\nscope.title = \"My title\";\r\nscope.subtitle = function() { return \"My subtitle\" };\r\nscope.$doNext = function(ev) { ... };\r\nscope.$anotherProperty = \"see below\";\r\n\r\nconsole.log(scope.$.snapshot());\r\n```\r\n\r\n```javascript\r\n{\r\n\ttitle: \"My title\",\r\n\tsubtitle: \"My subtitle\",\r\n\tdoNext: function(ev) { ... },\r\n\tanotherProperty: \"see below\"\r\n}\r\n```\r\n\r\nA snapshot is used when applying the scope to the DOM. This is how the declarations in the DOM can refer to `$` prefixed scope properties without the prefix.\r\n\r\nThe `snapshot` function includes properties from parent scopes. If you don’t want to include parent scopes, pass `false` for the optional `includeParents` parameter, e.g. `snapshot(false)`.\r\n\r\n#### Model\r\n\r\nThe snapshot includes properties that are not relevant if you want to submit data back to a server using Ajax, or give the data to other code. For this, use the `model` function. The `model` function behaves like `snapshot`, except rather than renaming any properties prefixed with the `$` character (or whatever the `eventHandlerPrefix` option is set to) they are removed.\r\n\r\nFollowing on from the snapshot example above:\r\n\r\n```javascript\r\nconsole.log(scope.$.model());\r\n```\r\n\r\n```javascript\r\n{\r\n\ttitle: \"My title\",\r\n\tsubtitle: \"My subtitle\"\r\n}\r\n```\r\n\r\nSo for use with Ajax, as an example:\r\n\r\n```javascript\r\nvar scope = $(\"#item\").consistent();\r\nscope.$.update();\r\n$.ajax({\r\n\tdata: scope.$.model()\r\n});\r\n```\r\n\r\nThe `model` function includes properties from parent scopes. If you don’t want to include parent scopes, pass false for the optional `includeParents` parameter, e.g. `model(false)`.\r\n\r\n#### Private properties\r\n\r\nWhat follows from the implementation of the `model` function, is that if you want to include properties in your scope that you don’t want to export out of the scope for Ajax or other purposes, you can prefix those properties with a `$` (or whatever the `eventHandlerPrefix` option is set to). You still refer to them without the `$` prefix in the binding declarations, so it is quite transparent.\r\n\r\n```html\r\n<h1 ct=\"title\"></h1>\r\n```\r\n\r\n```javascript\r\nscope.$title = \"My title\";\r\n\r\n// The following are both true\r\nscope.$.snapshot().title === \"My title\";\r\nscope.$.model().title === undefined;\r\n```\r\n\r\nLicense\r\n-------\r\n\r\nConsistent is released under the [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0).\r\n\r\nCompatibility\r\n-------------\r\n\r\nConsistent works in all modern browsers. It has also been tested, and works in its entirety, in IE 6, 7 and 8.\r\n\r\nPrinciples\r\n----------\r\n\r\n### Undefined\r\n\r\nIf a scope property is not defined then Consistent will not change the DOM.\r\n\r\n\r\nAdvanced\r\n--------\r\n\r\n### Nested properties\r\n\r\nYou can use nested properties in the scope.\r\n\r\n```html\r\n<h1 ct=\"person.fullName\"></h1>\r\n```\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent();\r\nscope.person = {\r\n\tfullName: \"Nathanial Hornblower\"\r\n};\r\nscope.$.apply();\r\n```\r\n\r\nWatch handler functions will be called with the `key` as the nested property name, eg. `person.fullName`. For convenience the scope declares two functions for working with nested property names.\r\n\r\n```javascript\r\nvar nestedPropertyName = \"person.fullName\";\r\nscope.$.get(nestedPropertyName);\r\nscope.$.set(nestedPropertyName, value);\r\n```\r\n\r\nIf the appropriate intermediate objects don’t exist, when calling `set`, they are created and added to the scope for you.\r\n\r\nNote that `get` will fall back to a parent scope, if there is one. See below for Parent scopes. If you don’t want to fall back to a parent scope pass true for the optional `includeParents` parameter, e.g. `get(key, false)` instead.\r\n\r\n### Parent scopes\r\n\r\nYou can create child scopes. Child scopes will look to their parent if they don’t contain a value for a given property key, in order to populate a DOM node or when looking for an event handler function. This includes value functions. Note that `this` inside the value function will be the child scope, rather than the scope in which it is defined.\r\n\r\nWhen `apply()` is called on a child scope, it automatically calls `apply()` on its parent scope.\r\n\r\nWatch handler functions added to parent scopes will be fired for changes in child scopes. Note that `this` inside the watch function will be the child scope, rather than the scope in which it is defined.\r\n\r\n```javascript\r\nvar rootScope = $.consistent(); /* Create the root scope */\r\nvar childScope = $.consistent(rootScope); /* Create a child scope */\r\n$(\"#item\").consistent(childScope); /* Bind a DOM node to the child scope */\r\n```\r\n\r\nNote that we have to create the scope and then bind the DOM node, rather than doing that at the same time as we have in other examples. This is because if you pass a scope as a parameter to the form with the selector it treats that as the scope to bind to. You have to call the `$.consistent` function in order to create a new scope with a parent. Note that `$.consistent` and `Consistent` are the same function.\r\n\r\nNow the following will work.\r\n\r\n```html\r\n<div id=\"item\">\r\n\t<h2 ct=\"title\"></h2>\r\n</div>\r\n```\r\n\r\n```javascript\r\nrootScope.title = \"Default title\";\r\nchildScope.$.apply();\r\n```\r\n\r\nThen if you add a title to the childScope and apply it again, it will override the title property in the parent.\r\n\r\nEvent handlers also work. Remember that event handlers receive a second argument which is the scope. This is particularly important when using parent scopes, as that argument will contain the originating scope, even if the event handler is declared in a parent scope.\r\n\r\n```html\r\n<div id=\"item\">\r\n\t<h2 ct=\"title\" ct-on-click=\"handleClick\"></h2>\r\n</div>\r\n```\r\n\r\n```javascript\r\nrootScope.$handleClick = function(ev, scope) {\r\n\t// scope === childScope\r\n\tscope.title += \".\";\r\n};\r\n```\r\n\r\n### Getting the nodes bound to a scope\r\n\r\nTo get an array of DOM nodes that have been bound to a scope, and that have declared bindings (e.g. have `ct...` attributes), you can use the `nodes()` function. Even if a node has been passed to a Consistent scope’s `bind` function, if a node doesn’t declare bindings then it will not be included in the result from `nodes()`.\r\n\r\n`nodes()` includes any bound nodes in child scopes as well. If you don’t want to include child scopes, pass true for the optional `includeParents` parameter, e.g. `nodes(false)`.\r\n\r\nNote that DOM nodes that define a repeating section (i.e. have a `ct-repeat` declaration) are not included in the result from `nodes()`, as those nodes no longer exist in the DOM. However, as nodes from child scopes are included the result may include the repeated nodes if they declare bindings.\r\n\r\nTo get an array of the DOM nodes that have been passed to a scope’s bind function use the `roots()` function. Note that the root nodes do not need to have declared Consistent bindings.\r\n\r\n```javascript\r\n$(scope.$.nodes()).addClass(\"found\");\r\n$(scope.$.roots()).addClass(\"found\");\r\n```\r\n\r\n### Repeating multiple root elements\r\n\r\nThe Repeating blocks section above introduces repeating. In that example you can only repeat a single root element, such as an `<li>` or a `<tr>`. Consistent also supports repeating a block of multiple root elements, which is useful if you want to add multiple table rows to a table for each block.\r\n\r\n```html\r\n<table>\r\n\t<tr ct-repeat=\"people\" ct-repeat-container-id=\"rows\"></tr>\r\n</table>\r\n\r\n<table style=\"display:none\">\r\n\t<tbody id=\"rows\">\r\n\t\t<tr>\r\n\t\t\t<td>Name</td>\r\n\t\t\t<td ct=\"name\"></td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>Address</td>\r\n\t\t\t<td ct=\"address\"></td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n```\r\n\r\nUsing the `ct-repeat-container-id` attribute you can identify nodes elsewhere in the DOM that should be cloned and used in the repeating block. Note that tables automatically get a `<tbody>` element created, even if it isn’t in the markup, therefore you should attach the id to an explicit `<tbody>` otherwise if the id is on the `<table>`, the repeating block will include the automatically created `<tbody>`.\r\n\r\n### Properties\r\n\r\nYou can set DOM element properties from the scope. Properties are DOM node Javascript properties, as opposed to attributes which are declared in the markup. The most common property to use is the `style` property, which exposes an object containing the DOM element’s style.\r\n\r\n```html\r\n<p ct-prop-style-display=\"showHide\">Lorem ipsum</p>\r\n```\r\n\r\nNote that properties may be nested, as in the case of `style.display` above, and we can specify this by `-` separating the property name when we declare the `ct-prop-` attribute.\r\n\r\n```javascript\r\nvar scope = $(\"p\").consistent();\r\nscope.showHide = \"none\";\r\nscope.$.apply();\r\n```\r\n\r\nThis sets the `style.display` property of the `<p>` element to \"none\", causing it not to be displayed.\r\n\r\nSee the Visibility section above for a better way to show and hide elements.\r\n\r\nOptions\r\n-------\r\n\r\n### Visibility animation\r\n\r\nOften you want to use animation to show or hide elements. You can override the behaviour of showing and hiding by specifying options when you create a scope, or bind a node.\r\n\r\n```javascript\r\nvar scope = $(\"h1\").consistent({\r\n\t$: {\r\n\t\tshow: function(dom) {\r\n\t\t\t// jQuery fade\r\n\t\t\t$(dom).fadeIn();\r\n\t\t},\r\n\t\thide: function(dom) {\r\n\t\t\t// jQuery fade\r\n\t\t\t$(dom).fadeOut();\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\nYou could also specify the show / hide implementation for a specific `apply`:\r\n\r\n```javascript\r\nscope.$.apply({\r\n\t$: {\r\n\t\tshow: function(dom) {\r\n\t\t\t// jQuery fade\r\n\t\t\t$(dom).fadeIn();\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\n### Repeating blocks animation\r\n\r\nIf you want to animate the appearance and disappearance of blocks in a repeating section, you can override the behaviour after adding nodes, and for removing nodes.\r\n\r\n```javascript\r\nvar options = { $: {} };\r\noptions.$.added = function(dom) {\r\n\t// jQuery hide and fadeIn\r\n\t$(dom).hide().fadeIn();\r\n};\r\noptions.$.remove = function(dom) {\r\n\t// jQuery fade then remove\r\n\t$(dom).fadeOut(function() {\r\n\t\t$(this).remove();\r\n\t});\r\n};\r\nvar scope = $(\"#container\").consistent(options);\r\n```\r\n\r\n### Change prefix for event handler and value functions\r\n\r\nIf you’re adding existing objects to your scopes that use naming conventions that don’t fit with Consistent; when Consistent makes a snapshot of the scope (which occurs whenever you apply the scope), you may get unexpected results such as functions in your scope being called unexpectedly. This is because Consistent has interpreted those functions as value functions.\r\n\r\nTo solve this issue you can pass options to the scope to change the way Consistent identifies value functions and event handler functions.\r\n\r\nBy default, keys containing event handlers are prefixed with a `$`, e.g. `$handleClick`. You can change this to any string by setting the option `eventHandlerPrefix`. You must still omit the prefix when declaring the event handler to bind to in the DOM.\r\n\r\nWhen you set an event handler prefix ending with a letter, e.g. \"do\", Consistent will expect the key to be camel-cased and will look for an event handler function specified as `ct-on=\"click\"` in the key `doClick`.\r\n\r\nBy default, keys containing value functions have no prefix – every function that doesn’t have a key prefixed with a `$` (or whatever the `eventHandlerPrefix` option is set to) is treated as a value function. You can change the value function prefix by setting the option `valueFunctionPrefix`. When there is a `valueFunctionPrefix` set, Consistent will only call functions that match the valuePrefix. Any functions that don’t match the value function prefix will be left untouched.\r\n\r\nWhen you use a value function prefix you must **not** include the prefix when declaring the binding in the DOM (same as for event handlers). The value function prefix is removed when the snapshot is created.\r\n\r\n```html\r\n<div id=\"container\">\r\n\t<h1 ct=\"title\"></h1>\r\n\t<button ct-on=\"click\">Button</button>\r\n</div>\r\n```\r\n\r\n```javascript\r\nvar options = {\r\n\teventHandlerPrefix: \"do\",\r\n\tvalueFunctionPrefix: \"get\"\r\n};\r\nvar scope = $(\"#container\").consistent(options);\r\nscope.getTitle = function() {\r\n\treturn \"Consistent.js\"\r\n};\r\nscope.doClick = function(ev) {\r\n\talert(\"Click!\");\r\n};\r\n```\r\n\r\nSee [Merging only specified keys](#merging-only-specified-keys) below for an alternative to this approach.\r\n\r\n### Merging only specified keys\r\n\r\nThe `merge` function provides an easy way to merge properties from existing objects into the scope. It also has an optional argument, `keys`, which is an array of strings. This enables you to pick and choose which properties from your existing objects you merge into the scope.\r\n\r\nThe keys array supports nested properties using `.` separators, e.g. `person.name`.\r\n\r\n```javascript\r\nvar object = {\r\n\ttitle: \"Consistent.js\",\r\n\tsubtitle: \"A JavaScript framework\",\r\n\tperson: {\r\n\t\tname: \"Arthur\",\r\n\t\tage: 4,\r\n\t\tgender: \"m\"\r\n\t},\r\n\tlocation: {\r\n\t\tcity: \"Auckland\",\r\n\t\tcountry: \"New Zealand\"\r\n\t},\r\n\tfriends: [\r\n\t\t\"Bob\",\r\n\t\t\"Carl\"\r\n\t]\r\n};\r\n\r\nscope.merge(object, [ \"title\", \"person.name\", \"person.age\", \"location\", friends\" ]);\r\n```\r\n\r\nThe above results in the title, the person’s name and age, and the location and friends arrays all being copied into the scope. The subtitle and the person’s gender are not copied.\r\n\r\nReference\r\n---------\r\n\r\n### DOM attributes\r\n\r\nBy default, DOM attributes are used to declare the binding between DOM nodes and the scope. The preferred attributes style starts with `ct`. You can also use `data-ct` instead of `ct`.\r\n\r\n#### Binding values\r\n\r\n* `ct` the name of a property in the scope to use to set the value of this element. Where setting the value means setting the `innerHTML`, or other properties as appropriate to the element type.\r\n* `ct-tmpl` a template that will be rendered with the scope as its context, and then used to set the value of this element.\r\n* `ct-tmpl-id` the id of a DOM element that contains template text, e.g. a `<script type=\"text/x-hogan-template\">` element.\r\n\r\n#### Form properties\r\n\r\n* `ct-disabled` make this element disabled when the named property in the scope is true.\r\n* `ct-enabled` make this element enabled when the named property in the scope is true.\r\n* `ct-readonly` make this element read-only when the named property in the scope is true.\r\n* `ct-readwrite` make this element not read-only when the named property in the scope is true.\r\n* `ct-options` set the `<select>` options array based on the array in the named property in the scope. The array should contain either scalar values, or objects each with `text` and `value` properties. Each object may also contain a `disabled` or `label` property to set those properties on the options.\r\n\r\n#### Attributes and properties\r\n\r\nThe `NAME` segment in the following list represents the name of the attribute or property. In the case of properties, the name will have -s changed to .s to enable access to nested properties, e.g. `ct-prop-style-display` affects the `style.display` property.\r\n\r\n* `ct-attr-NAME` the name of a property in the scope to use to set the value of the given attribute on this element.\r\n* `ct-prop-NAME` the name of a property in the scope to use to set the value of the given property on this element.\r\n* `ct-tmpl-attr-NAME` a template that will be rendered with the scope as its context, and then used to set the value of the given attribute on this element.\r\n* `ct-tmpl-id-attr-NAME` the id of a DOM element that contains template text.\r\n\r\n* `ct-attrs` the name of an object property in the scope with keys and values mapping to attribute names and values. Note that for setting the attribute `class` you should instead use `className` as `class` is sometimes a reserved word.\r\n* `ct-properties` the name of an object property in the scope with keys and values mapping to properties, including support for nested properties.\r\n\r\n* `ct-class` the name of a property in the scope to use to set the value of the `class` attribute on this element. Supports string and array values.\r\n* `ct-add-class` the name of a property in the scope to use to add classes to the existing `class` attribute on this element. Supports string and array values.\r\n\r\n#### Visibility\r\n\r\n* `ct-show` show this element when the named property in the scope is true, otherwise hide it.\r\n* `ct-hide` the opposite of show.\r\n\r\n#### Event handlers\r\n\r\n* `ct-on` binds the default event for this element to the named event handler function in the scope.\r\n* `ct-on-EVENT` binds the event named EVENT for this element to the named event handler function in the scope.\r\n\r\n#### Repeating blocks\r\n\r\n* `ct-repeat` repeats this element, and all of its children, for each item in the array in the named property in the scope.\r\n* `ct-repeat-container-id` the id of a DOM element that contains DOM nodes to be repeated in place of this element.\r\n\r\n\r\n### Scope functions\r\n\r\nAll scope functions are nested inside the `$` object, and therefore you call them, e.g. `scope.$.apply()`. All functions without an explicitly documented return value will return the scope to enable chaining, e.g. `scope.$.update().$.apply()`.\r\n\r\n#### DOM\r\n\r\n* `apply([options, ] [function])` applies the scope to the DOM. If the optional options are provided they augment each node’s options before applying. If the function argument is provided, the function is called with `this` set to the scope before the scope is applied.\r\n* `applyLater([options, ] [function])` as for `apply` but rather than applying immediately it creates a `setTimeout` with a 0 time so it will be called after the current Javascript event handling finishes. The function, if supplied, is called immediately. It is safe to call this multiple times, the scope will only be applied once.\r\n* `needsApply()` returns true if the scope has been changed and needs to be applied to the DOM. Changes include properties changed in the scope or new nodes bound to the scope.\r\n* `update()` updates the scope by reading keys and values from the DOM.\r\n* `bind(dom [, options])` binds the given DOM node to the scope. See the options section for the optional options argument. The `dom` parameter may also be an array of nodes.\r\n* `unbind(dom)` unbinds the given DOM node from the scope. The `dom` parameter may also be an array of nodes.\r\n* `nodes([includeParents])` returns an array of DOM nodes that have been bound to this scope and have bindings. Includes nodes in child scopes unless the optional `includeParents` parameter is false.\r\n* `roots()` returns an array of the DOM nodes explicitly bound to this scope, that is the nodes that were passed to the `bind` function.\r\n\r\n#### Scope\r\n* `snapshot([includeParents])` returns a Javascript object containing the scope’s model properties, excluding the Consistent `$` object, any properties prefixed with a `$` (usually event handlers) and evaluating value functions and replacing with their current values. Includes properties in parent scopes unless the optional `includeParents` parameter is false.\r\n* `merge([deep, ] object)` merges properties from the given object into the scope. If deep is provided it is a boolean indicating whether to do a deep merge. A normal merge simply copies across all of the keys in object, replacing any existing objects, whereas a deep merge will merge objects.\r\n* `merge(object, keys)` merges the properties named in the keys array from the given object into the scope. The keys argument may be an array of key names or a single key, and may include nested properties using dot notation, e.g. `[ \"name\", \"address.street\" ]`.\r\n* `replace(object)` replaces the scope with the given object. The given object is actually used as the scope, and Consistent’s `$` object is added into this new object. The return value is the object given.\r\n* `clear()` removes all properties from the scope. This only leaves Consistent’s `$` object.\r\n\r\n* `get(key [, includeParents])` returns the value in the scope for the given key. Supports nested keys (i.e. that contain dot notation) and falls back to parent scopes if the scope doesn’t have a property for the given key itself, unless the optional `includeParents` parameter is false. The value may be a scalar value or a function (in the case of a value function or event handler) if the scope contains a property with the given key, otherwise it returns undefined.\r\n* `set(key, value)` sets the value in the scope for the given key. Supports nested keys. If the target key exists and contains a value function, the value function is called passing the value as the only argument.\r\n\r\n* `getEventHandler(key [, includeParents])` returns the event handler in the scope for the given key. Supports nested keys and falls back to parent scopes, unless the optional `includeParents` parameter is false. The event handler prefix (by default `$`) is added to the last component of the key and must not be included in the `key` parameter, e.g. `getEventHandler(\"people.handleClick\")` to access `people.$handleClick`.\r\n* `setEventHandler(key, function)` sets the event handler in the scope for the given key. Supports nested keys. Adds the `$` prefix to the last component of the key.\r\n\r\n#### Watch\r\n* `watch([key,] function)` adds the given handler function as a watch function to the key, if provided, otherwise to the whole scope.\r\n* `unwatch([key,] function)` unbinds the watch function.\r\n\r\n#### General\r\n* `parent()` returns the parent scope, or null if there is no parent scope.\r\n* `children()` returns an array containing the immediate child scopes of this scope.\r\n* `options([node])` returns the options object for the given node, or for the scope as a whole. Note that you can modify the returned options object, but changes to the scope’s options will not affect node options.\r\n\r\n### Scope properties\r\n\r\nThe scope exposes some properties inside the `$` object, e.g. `scope.$.index`.\r\n\r\n* `index` the 0-based index of the given scope within a repeating section, or undefined if not in a repeating section.\r\n\r\n### Consistent functions\r\n\r\n* `Consistent([options])` returns a new scope. If the options are provided the scope is initialised with them.\r\n* `Consistent(parentScope [, options])` returns a new scope and sets its parent scope. If the options are provided the scope is initialised with them.\r\n* `Consistent(node)` returns the scope the DOM node is bound to, or null.\r\n* `Consistent.isScope(object)` returns true if the given object is a Consistent scope.\r\n\r\n### jQuery plugin\r\n\r\n* `$.consistent` is synonymous with the `Consistent` function above and can be used in the same way.\r\n* `$(selector).consistent()` checks the selected elements to see if they have been bound to a scope. If they’ve all been bound to the same scope, it returns that scope. If they’ve been bound to different scopes (or some have been bound and some haven’t) this throws an exception. If they haven’t been bound to a scope a new scope is created, the elements are bound and the scope is returned.\r\n* `$(selector).consistent(options)` creates a new scope with the given options, binds the selected elements to it and returns the scope.\r\n* `$(selector).consistent(scope [, options])` binds the selected nodes to the given scope, with the options if provided and returns the scope.\r\n\r\nWhat Consistent doesn’t do\r\n--------------------------\r\n\r\nConsistent doesn’t create DOM nodes. There are great tools for creating DOM nodes, such as simply using jQuery or using a templating engine such as Mustache or Hogan (which I’ve used in the examples). You can easily create new DOM nodes and then bind a new Consistent scope to them. Note that Consistent does in fact create DOM nodes if you create them in templates; however see the [templating section](#templating) for advice about that.\r\n\r\nConsistent doesn’t do any Ajax. Consistent scopes can be easily populated from an Ajax JSON response, and their data can be easily exported for sending to a server. Look at the `scope.$.merge(object)` and `scope.$.model()` functions, respectively.\r\n\r\nTroubleshooting\r\n---------------\r\n\r\n### Functions in objects in the scope are called unexpectedly\r\n\r\nSee the section [Change prefix for event handler and value functions](#change-prefix-for-event-handler-and-value-functions) above for an explanation and a solution to this problem.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}